export const langgraphDocs =
  '<guide>\n<introduction>\nLangGraph is a powerful framework for building agentic applications using large language models (LLMs). It provides a flexible and controllable way to create complex workflows and decision-making processes driven by LLMs. This guide will explore the core concepts of LangGraph, demonstrate how to implement them, and provide best practices for building robust agentic systems.\n</introduction>\n\n<key_concepts>\n1. Graphs: The fundamental structure for modeling agent workflows\n2. State: The shared data structure representing the current snapshot of the application\n3. Nodes: JavaScript/TypeScript functions that encode the logic of agents\n4. Edges: Functions that determine the flow between nodes\n5. Checkpointers: Persistence layer for managing state across interactions\n6. Threads: Unique identifiers for separate runs of a graph\n7. Streaming: Real-time updates of graph execution\n8. Human-in-the-loop: Interaction patterns for human oversight and intervention\n</key_concepts>\n\n<detailed_explanations>\n1. Graphs\n\nGraphs are the core structure in LangGraph for modeling agent workflows. They consist of nodes (which perform actions) and edges (which define the flow between nodes).\n\nExample:\n```typescript\nconst graphBuilder = new StateGraph<ChatbotState>({\n  channels: {\n    messages: {\n      default: () => [],\n      reducer: (prev: BaseMessage[], next: BaseMessage[]) => [...prev, ...next],\n    },\n    current_action: {\n      default: () => null,\n      reducer: (_, next) => next,\n    },\n  },\n});\n\ngraphBuilder\n  .addNode("route", routeNode)\n  .addNode("respond", respondNode)\n  .addNode("action", actionNode)\n  .addEdge(START, "route")\n  .addConditionalEdges("route", (state) => state.current_action as string, {\n    respond: "respond",\n    action: "action",\n  })\n  .addEdge("respond", END)\n  .addEdge("action", END);\n\nconst graph = graphBuilder.compile();\n```\n\nThis structure allows for complex, multi-step processes with conditional logic, making it ideal for agentic applications.\n\n2. State\n\nState in LangGraph represents the current snapshot of your application. It\'s defined using a `channels` object and can include custom reducers for complex update logic.\n\nExample:\n```typescript\ninterface ChatbotState {\n  messages: BaseMessage[];\n  current_action: string | null;\n}\n\nconst graphBuilder = new StateGraph<ChatbotState>({\n  channels: {\n    messages: {\n      default: () => [],\n      reducer: (prev: BaseMessage[], next: BaseMessage[]) => [...prev, ...next],\n    },\n    current_action: {\n      default: () => null,\n      reducer: (_, next) => next,\n    },\n  },\n});\n```\n\nThe state is crucial as it\'s passed between nodes and determines the flow of the graph.\n\n3. Nodes\n\nNodes are JavaScript/TypeScript functions that perform the actual work in your graph. They receive the current state, perform some action, and return an updated state.\n\nExample:\n```typescript\nconst respondNode = (state: ChatbotState) => {\n  console.log("Generating response");\n  return {\n    messages: [new AIMessage("This is a mock response to your query.")],\n  };\n};\n```\n\nNodes can contain LLM calls, API requests, or any other logic needed for your application.\n\n4. Edges\n\nEdges define the flow between nodes. They can be simple connections or conditional, allowing for dynamic routing based on the current state.\n\nExample:\n```typescript\ngraphBuilder\n  .addEdge(START, "route")\n  .addConditionalEdges("route", (state) => state.current_action as string, {\n    respond: "respond",\n    action: "action",\n  });\n```\n\nEdges are key to creating flexible, adaptive workflows in your agentic applications.\n\n5. Checkpointers\n\nCheckpointers provide a persistence layer, allowing you to save and resume the state of your graph. This is crucial for implementing features like memory and human-in-the-loop interactions.\n\nExample:\n```typescript\nconst graph = graphBuilder.compile({\n  checkpointer: new MemorySaver(),\n});\n```\n\nCheckpointers enable advanced features like time travel and edit-in-place for agent actions.\n\n6. Threads\n\nThreads are unique identifiers for separate runs of a graph. They\'re essential for managing multiple concurrent executions, especially in multi-tenant applications.\n\nExample:\n```typescript\nconst config = { configurable: { thread_id: threadId } };\nconst finalState = await graph.invoke(initialState, config);\n```\n\nProper use of threads ensures that state is maintained correctly across multiple interactions or users.\n\n7. Streaming\n\nLangGraph supports streaming of both events and LLM tokens, allowing for real-time updates during graph execution.\n\nExample:\n```typescript\nconst stream = await searchGraph.stream(initialState, {\n  ...config,\n  configurable: { ...config?.configurable, stream_events: true },\n});\n```\n\nStreaming is crucial for providing responsive user experiences, especially for long-running processes.\n\n8. Human-in-the-loop\n\nLangGraph supports various human-in-the-loop interaction patterns, such as approval flows, waiting for input, and editing agent actions.\n\nExample:\n```typescript\nconst graph = graphBuilder.compile({\n  checkpointer: new MemorySaver(),\n});\n\n// Later, in your application logic:\nawait graph.invoke(null, config); // Resume after human input\n```\n\nThese patterns are essential for building reliable and trustworthy agentic systems.\n\n</detailed_explanations>\n\n<advanced_topics>\n1. Multi-agent architectures: LangGraph can be used to orchestrate complex systems with multiple LLM-based agents, each represented as a node in the graph.\n\n2. Planning and reflection: Implement explicit planning steps and reflection mechanisms to improve the reliability and effectiveness of your agentic systems.\n\n3. Tool calling: Integrate external tools and APIs into your graph, allowing agents to interact with the outside world and access additional capabilities.\n\n4. Custom reducers: Implement sophisticated state update logic using custom reducers, enabling complex state management in your applications.\n\n5. Graph migrations: LangGraph supports migrating graph definitions even when using checkpointers, allowing for evolving your application over time.\n</advanced_topics>\n\n<best_practices>\n1. Define clear state interfaces: Always create explicit interfaces for your graph state to ensure type safety and prevent runtime errors.\n\n2. Use appropriate reducers: Implement custom reducers for state fields that require complex update logic to maintain consistency.\n\n3. Implement error handling: Include error handling nodes and edges in your graph to gracefully manage potential failures.\n\n4. Leverage conditional edges: Use conditional edges to create dynamic, adaptive workflows based on the current state.\n\n5. Use checkpointers for stateful graphs: Always use a checkpointer when implementing stateful graphs to enable persistence and human-in-the-loop workflows.\n\n6. Specify thread IDs: When using checkpointers, always specify a thread_id in the configuration to properly manage multiple concurrent graph executions.\n\n7. Implement streaming: Use streaming capabilities to provide real-time feedback and improve user experience for long-running processes.\n\n8. Design for human oversight: Incorporate human-in-the-loop patterns in sensitive or critical decision-making processes to ensure reliability and trustworthiness.\n</best_practices>\n\n<common_pitfalls>\n1. Overlooking state management: Failing to properly define and manage state can lead to inconsistent or unexpected behavior in your graph.\n\n2. Ignoring error handling: Not implementing proper error handling can result in crashes or unhandled exceptions in production.\n\n3. Overcomplicating graph structure: Creating overly complex graphs can make your application difficult to understand and maintain. Strive for a balance between flexibility and simplicity.\n\n4. Neglecting human oversight: Relying too heavily on autonomous decision-making without human intervention can lead to unreliable or potentially harmful outcomes.\n\n5. Improper thread management: Failing to use thread IDs correctly can result in state conflicts in multi-tenant applications.\n\n6. Ignoring performance considerations: Not optimizing for performance, especially in graphs with many nodes or complex operations, can lead to slow response times and poor user experience.\n</common_pitfalls>\n\n<conclusion>\nLangGraph provides a powerful and flexible framework for building agentic applications using large language models. By leveraging graphs, state management, and advanced features like checkpointing and streaming, developers can create sophisticated, adaptive, and reliable AI-driven systems. The framework\'s support for human-in-the-loop interactions and multi-agent architectures makes it suitable for a wide range of applications, from chatbots and virtual assistants to complex decision-making systems and workflow automation tools. As AI continues to evolve, LangGraph offers a robust foundation for building the next generation of intelligent applications that can reason, plan, and act in increasingly complex environments.\n</conclusion>\n</guide>';
