export const nodeCreatorPrompt =
  '# Comprehensive Guide to Building Nodes in LangGraph\n\n## 1. Introduction to Nodes in LangGraph\n\nNodes are fundamental components in LangGraph that represent discrete steps or operations within your agent\'s workflow. They are essentially JavaScript/TypeScript functions that receive the current state as input, perform some computation or side-effect, and return an updated state.\n\n## 2. Types of Nodes\n\n### 2.1 Basic Nodes\nSimple functions that process the state and return an update.\n\n### 2.2 LLM-based Nodes\nNodes that incorporate language models for decision-making or text generation.\n\n### 2.3 Tool-calling Nodes\nNodes that interact with external tools or APIs.\n\n### 2.4 Special Nodes\n- START Node: Represents the entry point of the graph.\n- END Node: Represents a terminal node in the graph.\n\n## 3. Creating Basic Nodes\n\nStep-by-step instructions:\n\n1. Define your node function:\n```typescript\nconst myNode = (state: State, config?: RunnableConfig) => {\n  // Process state\n  // Return state update\n};\n```\n\n2. Add the node to your graph:\n```typescript\ngraphBuilder.addNode("myNode", myNode);\n```\n\n## 4. Advanced Node Configurations\n\n### 4.1 Configurable Nodes\nCreate nodes that can be configured at runtime:\n\n```typescript\nconst configurableNode = (state: State, config?: RunnableConfig) => {\n  const customParam = config?.configurable?.customParam;\n  // Use customParam in your node logic\n};\n```\n\n### 4.2 Async Nodes\nFor operations that require asynchronous processing:\n\n```typescript\nconst asyncNode = async (state: State, config?: RunnableConfig) => {\n  const result = await someAsyncOperation(state.input);\n  return { output: result };\n};\n```\n\n## 5. Best Practices for Node Implementation\n\n1. Keep nodes focused on a single responsibility.\n2. Use TypeScript interfaces to define expected state structure.\n3. Implement error handling within nodes.\n4. Use meaningful names for nodes and their functions.\n5. Document the purpose and expected inputs/outputs of each node.\n\n## 6. Common Pitfalls and How to Avoid Them\n\n1. Mutating state directly: Always return a new state object or use reducers.\n2. Ignoring error handling: Implement try-catch blocks for potential errors.\n3. Overcomplicating nodes: Break complex logic into multiple simpler nodes.\n4. Forgetting to compile the graph: Always call `.compile()` before using the graph.\n\n## 7. Integrating Nodes with Other LangGraph Components\n\n### 7.1 Connecting Nodes with Edges\nUse `addEdge` or `addConditionalEdges` to define the flow between nodes:\n\n```typescript\ngraphBuilder.addEdge("nodeA", "nodeB");\ngraphBuilder.addConditionalEdges("nodeC", routingFunction);\n```\n\n### 7.2 Using Nodes with Checkpointers\nImplement checkpointing to enable persistence and human-in-the-loop workflows:\n\n```typescript\nconst graph = graphBuilder.compile({\n  checkpointer: new InMemoryCheckpointer()\n});\n```\n\n### 7.3 Streaming from Nodes\nImplement streaming to provide real-time updates:\n\n```typescript\nconst streamingNode = async function* (state: State) {\n  yield { status: "Processing" };\n  // Perform operations\n  yield { status: "Complete", result: someResult };\n};\n```\n\n## 8. Advanced Topics\n\n### 8.1 Implementing Reflection in Nodes\nCreate nodes that can analyze their own output and make decisions:\n\n```typescript\nconst reflectiveNode = async (state: State) => {\n  const result = await performOperation(state.input);\n  const analysis = await analyzeResult(result);\n  return { result, analysis };\n};\n```\n\n### 8.2 Multi-agent Nodes\nDesign nodes that facilitate communication between multiple agents:\n\n```typescript\nconst multiAgentNode = async (state: State) => {\n  const agentAResponse = await agentA.process(state.input);\n  const agentBResponse = await agentB.process(agentAResponse);\n  return { agentAResponse, agentBResponse };\n};\n```\n\n## 9. Conclusion\n\nBuilding effective nodes in LangGraph requires a good understanding of state management, function composition, and the overall graph structure. By following the best practices and avoiding common pitfalls, you can create robust and flexible agent workflows. Remember to leverage LangGraph\'s features like checkpointing, streaming, and conditional routing to build sophisticated agentic applications.';
